<!DOCTYPE html>
<html>
	<head>
		<title></title>
		<meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0"/>
		<style type="text/css">
			body {
				margin: 0;
				overflow: hidden;
			}

			#stats {
				position: absolute;
				top: 0;
				z-index: 2;
			}
		</style>

		<script type="text/x-shader" id="vertexShader">
			#define PI 3.141592653589793
			#define PI_2 6.283185307179586

			#define PACKED_COLOR_SIZE 256.0
			#define PACKED_COLOR_DIVISOR 255.0

			uniform float deltaTime;
			uniform float runTime;

			attribute vec4 acceleration;
			attribute vec3 velocity;
			attribute vec4 rotation;
			attribute vec3 rotationCenter;
			attribute vec4 params;
			attribute vec4 size;
			attribute vec4 angle;
			attribute vec4 color;
			attribute vec4 opacity;

			varying vec4 vColor;
			varying float vAngle;
			// varying float vIsAlive;

			// Branch-avoiding comparison fns
			// - http://theorangeduck.com/page/avoiding-shader-conditionals
			float when_gt(float x, float y) {
			    return max(sign(x - y), 0.0);
			}

			float when_lt(float x, float y) {
			    return min( max(1.0 - sign(x - y), 0.0), 1.0 );
			}

			float when_eq( float x, float y ) {
			    return 1.0 - abs( sign( x - y ) );
			}

			float when_ge(float x, float y) {
			  return 1.0 - when_lt(x, y);
			}

			float when_le(float x, float y) {
			  return 1.0 - when_gt(x, y);
			}

			// Branch-avoiding logical operators
			// (to be used with above comparison fns)
			float and(float a, float b) {
			    return a * b;
			}

			float or(float a, float b) {
			    return min(a + b, 1.0);
			}



			// From:
			// - http://stackoverflow.com/a/12553149
			// - https://stackoverflow.com/questions/22895237/hexadecimal-to-rgb-values-in-webgl-shader
			vec3 unpackColor( in float hex ) {
				vec3 c = vec3( 0.0 );

			  	float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );
			  	float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );
			  	float b = mod( hex, PACKED_COLOR_SIZE );

			  	c.r = r / PACKED_COLOR_DIVISOR;
			  	c.g = g / PACKED_COLOR_DIVISOR;
			  	c.b = b / PACKED_COLOR_DIVISOR;

				return c;
			}

			float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {
				float value = 0.0;
	            float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH );
	            float fIndex = 0.0;
	            float shouldApplyValue = 0.0;

	            // This might look a little odd, but it's quite elegant. Uses
	            // basic maths to avoid branching. Nice.
	            //
	            // Take a look at the branch-avoidance functions defined above,
	            // and be sure to check out The Orange Duck site where I got this
	            // from (link above).
	            for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {
	            	fIndex = float( i );
	            	shouldApplyValue = and( when_ge( deltaAge, fIndex ), when_lt( deltaAge, fIndex + 1.0 ) );
	            	value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );
	            }

	            return value;
	        }

			vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {
				vec3 value = vec3( 0.0 );
	            value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );
	            value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );
	            value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );
	            return value;
	        }


	        float getAlive() {
	        	return params.x;
	        }

	        float getDelay() {
	        	return params.z;
	        }

	        float getAge() {
	        	return params.y;
	        }


	        float getMaxAge() {
	        	return max( getAge(), params.z );
	        }

	        float getWiggle() {
	        	return params.w;
	        }

	        vec4 getPosition( in float age ) {
	        	return modelViewMatrix * vec4( position, 1.0 );
	        }

	        vec3 getVelocity( in float age ) {
	        	return velocity * age;
	        }

	        vec3 getAcceleration( in float age ) {
	        	return acceleration.xyz * age;
	        }

	        // Huge thanks to:
	        // - http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/
	        mat4 getRotationMatrix( in vec3 axis, in float angle) {
			    axis = normalize(axis);
			    float s = sin(angle);
			    float c = cos(angle);
			    float oc = 1.0 - c;

			    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
			                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
			                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
			                0.0,                                0.0,                                0.0,                                1.0);
			}

	        vec3 getRotation( in vec3 pos, in float positionInTime ) {
	        	vec3 axis = unpackColor( rotation.x );
	        	vec3 center = rotationCenter;
	        	vec3 translated;
	        	mat4 rotationMatrix;

	        	float angle = 0.0;
	        	angle += when_eq( rotation.z, 0.0 ) * rotation.y;
	        	angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime * 1.35 );

	        	// if( rotation.z == 0.0 ) {
		        // 	angle = rotation.y;
		        // 	// center = rotationCenter;
		        // }
		        // else {
		        // 	// Can't figure out why positionInTime needs to be
		        // 	// multiplied by 1.35 here. It should be a value between
		        // 	// 0.0 and 1.0, but apparently not :|
		        // 	//
		        // 	// If I don't multiply by 1.35 here, then the rotation
		        // 	// angle isn't adhered to. It falls short..!
		        // 	angle = mix( 0.0, rotation.y, positionInTime * 1.35 );
		        // 	// center = vec3(rotationCenter);
		        // 	// translated = rotationCenter - pos;
		        // }

	        	translated = rotationCenter - pos;
	        	rotationMatrix = getRotationMatrix( axis, angle );
	        	return center + vec3( rotationMatrix * vec4( translated, 1.0 ) );
	        }

	        void main() {
	        	//
	        	// Setup...
	        	//
	        	float delay = getDelay();
	        	float age = getAge();
	        	float alive = getAlive();
	        	float maxAge = getMaxAge();
	        	float positionInTime = (age / maxAge);
	        	float wiggleAmount = positionInTime * getWiggle();
	        	float wiggleSin = sin( wiggleAmount );
	        	float wiggleCos = cos( wiggleAmount );
	        	float isAlive = when_gt( alive, 0.0 );



	        	// Save the value is isAlive to a varying for
	        	// access in the fragment shader
	        	// vIsAlive = isAlive;



	        	//
	        	// Forces
	        	//

	        	// Get forces & position
	        	vec3 vel = getVelocity( age );
	        	vec3 accel = getAcceleration( age );
	        	vec3 force = vec3( 0.0 );
	        	vec3 pos = vec3( position );

	        	// Can't figure out why positionInTime needs to be multiplied
	        	// by 0.6 to give the desired result...Should be value between
	        	// 0.0 and 1.0!?
	        	float drag = (1.0 - (positionInTime * 0.6) * acceleration.w);

	        	// Integrate forces...
	        	force += vel;
	        	force *= drag;
	        	force += accel * age;
	        	pos += force;


	        	// Wiggly wiggly wiggle!
	        	pos.x += wiggleSin;
	        	pos.y += wiggleCos;
	        	pos.z += wiggleSin;


	        	// Rotate the emitter around it's central point
	        	pos = getRotation( pos, positionInTime );

	        	// Convert pos to a world-space value
	        	vec4 mvPos = modelViewMatrix * vec4( pos, 1.0 );

	        	// Determine point size.
	        	// #ifdef USING_SIZE_OVER_LIFETIME
        			float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;
        		// #else
        			// float pointSize = size.x * isAlive;
        		// #endif

	        	// Determine perspective
	        	// TODO: Accept camera here via `scale` uniform
	        	#ifdef HAS_PERSPECTIVE
	        		float perspective = 300.0 / length( mvPos.xyz );
	        	#else
	        		float perspective = 1.0;
	        	#endif

	        	// Apply perpective to pointSize value
	        	float pointSizePerspective = pointSize * perspective;


	        	//
	        	// Appearance
	        	//

	        	// Determine color and opacity for this particle
	        	// #ifdef USING_COLOR_OVER_LIFETIME
	        	#ifdef COLORIZE
		        	vec3 c = isAlive * getColorOverLifetime(
		        		positionInTime,
		        		unpackColor( color.x ),
		        		unpackColor( color.y ),
		        		unpackColor( color.z ),
		        		unpackColor( color.w )
		        	);
		        #else
		        	// vec3 c = unpackColor( color.x ) * isAlive;
		        	vec3 c = vec3(1.0);
	        	#endif

	        	// #ifdef USING_OPACITY_OVER_LIFETIME
		        	float o = isAlive * getFloatOverLifetime( positionInTime, opacity );
		        // #else
		        	// float o = opacity.x * isAlive;
		        // #endif

	        	// Assign color to vColor varying.
	        	vColor = vec4( c, o );

	        	// Determine angle
	        	vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );



	        	//
	        	// Write values
	        	//

	        	// Set PointSize according to size at current point in time.
	        	gl_PointSize = pointSizePerspective;
	        	gl_Position = projectionMatrix * mvPos;
	        }
		</script>

		<script type="text/x-shader" id="fragmentShader">
			uniform sampler2D texture;

			varying vec4 vColor;
			varying float vAngle;
			// varying float vIsAlive;

			void main() {
				// float a = vAngle;
				// gl_FragColor = vec4( vColor );

				vec3 outgoingLight = vColor.xyz;

		        // float c = cos( vAngle );
		        // float s = sin( vAngle );
		        // float x = gl_PointCoord.x - 0.5;
		        // float y = gl_PointCoord.y - 0.5;

		        // vec2 rotatedUV = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );
		        // vec4 rotatedTexture = texture2D( texture, rotatedUV );

		        // #ifdef COLORIZE
		        //    outgoingLight = vColor.xyz * rotatedTexture.xyz;
		        // #else
		        //    outgoingLight = vec3( rotatedTexture.xyz );
		        // #endif


		        // gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );
		        gl_FragColor = vec4( outgoingLight.xyz, vColor.w );
			}
		</script>
	</head>
	<body>
		<script type="text/javascript" src="../../examples/js/THREE-r72.js"></script>
		<script type="text/javascript" src="../../examples/js/Stats.min.js"></script>
		<script type="text/javascript" src="../SPE.js"></script>
		<script type="text/javascript" src="../helpers/SPE.TypedArrayHelper.js"></script>
		<script type="text/javascript" src="../helpers/SPE.ShaderAttribute.js"></script>
		<script type="text/javascript" src="../shaders/SPE.shaders.js"></script>
		<script type="text/javascript" src="../core/SPE.utils.js"></script>
		<script type="text/javascript" src="../core/SPE.Group.js"></script>
		<script type="text/javascript" src="../core/SPE.Emitter.js"></script>

		<script type="text/javascript">
			// Override shaders with ones above.
			SPE.shaders.vertex = document.getElementById( 'vertexShader' ).textContent;
			SPE.shaders.fragment = document.getElementById( 'fragmentShader' ).textContent;


			var scene = new THREE.Scene(),
				camera = new THREE.PerspectiveCamera( 64, window.innerWidth / window.innerHeight, 0.1, 10000 ),
				renderer = new THREE.WebGLRenderer( { antialias: true } ),
				stats = new Stats(),
				clock = new THREE.Clock(),

				group = new SPE.Group( {
					// blending: THREE.NormalBlending
					colorize: true,
					transparent: true
				} ),

				emitter = new SPE.Emitter( {
					particleCount: 500,

					maxAge: {
						value: 2,
						spread: 1
					},

					rotation: {
						axis: new THREE.Vector3( 0, 1, 0 ),
						axisSpread: new THREE.Vector3( 0.2, 0, 0.2 ),
						angle: 0, // radians
						angleSpread: Math.PI * 2,
						static: false,
						center: new THREE.Vector3( 0, 0, 0 )
					},

					radius: {
						value: 5,
						spread: 0,
						scale: new THREE.Vector3( 1, 1, 1 )
					},

					position: {
						value: new THREE.Vector3( 0, 0, 0 ),
						spread: new THREE.Vector3( 20, 0, 20 ),
						spreadClamp: new THREE.Vector3( 5, 5, 5 ),
						distribution: SPE.distributions.SPHERE,
						// randomise: false
					},

					velocity: {
						value: new THREE.Vector3( 0, -5, 0 ),
						spread: new THREE.Vector3( 0, 0, 0 ),
						distribution: SPE.distributions.BOX,
						// randomise: false
					},

					acceleration: {
						value: new THREE.Vector3( 0, -5, 0 ),
						spread: new THREE.Vector3( 0, 0, 0 ),
						distribution: SPE.distributions.BOX,
						// randomise: false
					},

					drag: {
						value: 1,
						spread: 0
					},

					wiggle: {
						value: 0,
						spread: 10
					},

					size: {
						value: [1, 1, 1, 0]
					},

					color: {
						value: [ new THREE.Color( 1, 1, 0 ), new THREE.Color( 1, 0, 0 ) ]
					},

					opacity: {
						value: [ 0, 1, 1, 1 ]
					}
				});

			group.addEmitter( emitter );
			scene.add( group.mesh );

			camera.position.z = 50;
			camera.lookAt( scene.position );

			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			document.body.appendChild( stats.domElement );

			function animate() {
				requestAnimationFrame( animate );

				// Simulate low frame-rate
				// setTimeout( animate, 1000 / (Math.random() * 60 | 0) );

				stats.update();
				// camera.position.x = Math.cos( Date.now() * 0.001 ) * 100;
				// camera.position.z = Math.sin( Date.now() * 0.001 ) * 100;
				// camera.lookAt( scene.position );
				render();
			}

			function render() {
				var dt = clock.getDelta();
				group.tick( dt );
				renderer.render( scene, camera );
			}

			console.log( group );
			console.log( emitter );

			animate();

		</script>
	</body>
</html>