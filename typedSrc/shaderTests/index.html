<!DOCTYPE html>
<html>
	<head>
		<title></title>
		<meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0"/>
		<style type="text/css">
			body {
				margin: 0;
				overflow: hidden;
			}

			#stats {
				position: absolute;
				top: 0;
				z-index: 2;
			}
		</style>

		<script type="text/x-shader" id="vertexShader">
			#define PI 3.141592653589793
			#define PI_2 6.283185307179586

			uniform float deltaTime;
			uniform float runTime;

			attribute vec4 acceleration;
			attribute vec3 velocity;
			attribute vec3 rotation;
			attribute vec4 params;
			attribute vec4 size;
			attribute vec4 angle;
			attribute vec4 color;
			attribute vec4 opacity;

			varying vec4 vColor;
			// varying float vAngle;
			// varying float vIsAlive;

			// Branch-avoiding comparison fns
			// - http://theorangeduck.com/page/avoiding-shader-conditionals
			float when_gt(float x, float y) {
			    return max(sign(x - y), 0.0);
			}

			float when_lt(float x, float y) {
			    return min( max(1.0 - sign(x - y), 0.0), 1.0 );
			}

			float when_eq( float x, float y ) {
			    return 1.0 - abs( sign( x - y ) );
			}

			float when_ge(float x, float y) {
			  return 1.0 - when_lt(x, y);
			}

			float when_le(float x, float y) {
			  return 1.0 - when_gt(x, y);
			}

			// Branch-avoiding logical operators
			// (to be used with above comparison fns)
			float and(float a, float b) {
			    return a * b;
			}

			float or(float a, float b) {
			    return min(a + b, 1.0);
			}



			// From:
			// - http://stackoverflow.com/a/12553149
			// - https://stackoverflow.com/questions/22895237/hexadecimal-to-rgb-values-in-webgl-shader
			vec3 unpackColor( in float hex ) {
				vec3 c = vec3( 0.0 );

			  	float r = mod( (hex / 256.0 / 256.0), 256.0 );
			  	float g = mod( (hex / 256.0), 256.0 );
			  	float b = mod( hex, 256.0 );

			  	c.r = r / 255.0;
			  	c.g = g / 255.0;
			  	c.b = b / 255.0;

				return c;
			}




			float getFloatOverLifetime(
				float positionInTime,
				in vec4 attr
			) {
				float value = 0.0;
	            float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH );

	            // This might look a little odd, but it's quite elegant. Uses
	            // basic maths to avoid branching. Nice.
	            //
	            // Take a look at the branch-avoidance functions defined above,
	            // and be sure to check out The Orange Duck site where I got this
	            // from (link above).
	            // value += attr.x * when_eq( deltaAge, 0.0 );
	            // value += mix( attr.x, attr.y, deltaAge ) * and( when_ge( deltaAge, 0.0 ), when_lt( deltaAge, 1.0 ) );
	            // value += mix( attr.y, attr.z, deltaAge - 1.0) * and( when_ge( deltaAge, 1.0 ), when_lt( deltaAge, 2.0 ) );
	            // value += mix( attr.z, attr.w, deltaAge - 2.0) * and( when_ge( deltaAge, 2.0 ), when_le( deltaAge, 3.0 ) );
	            // value += attr.z * when_gt( deltaAge, 3.0 );

	            for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {
	            	float fIndex = float( i );

	            	value += mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex ) * and( when_ge( deltaAge, fIndex ), when_lt( deltaAge, fIndex + 1.0 ) );
	            }

	            return value;
	        }

			vec3 getColorOverLifetime(
				float positionInTime,
				in vec3 color1,
				in vec3 color2,
				in vec3 color3,
				in vec3 color4
			) {
				vec3 value = vec3( 0.0 );

	            value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );
	            value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );
	            value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );

	            return value;
	        }


	        float getAlive() {
	        	return params.x;
	        }

	        float getDelay() {
	        	return params.z;
	        }

	        float getAge() {
	        	return params.y;
	        }


	        float getMaxAge() {
	        	return max( getAge(), params.z );
	        }

	        // float getParticleStartTime() {
	        // 	return params.w;
	        // }


	        vec4 getPosition( in float age ) {
	        	return modelViewMatrix * vec4( position, 1.0 );
	        }

	        vec3 getVelocity( in float age ) {
	        	return velocity * age;
	        }

	        vec3 getAcceleration( in float age ) {
	        	return acceleration.xyz * age;
	        }

	        // Huge thanks to:
	        // - http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/
	        mat4 getRotationMatrix(vec3 axis, float angle) {
			    axis = normalize(axis);
			    float s = sin(angle);
			    float c = cos(angle);
			    float oc = 1.0 - c;

			    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
			                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
			                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
			                0.0,                                0.0,                                0.0,                                1.0);
			}

	        vec3 getOrbitPosition( in vec3 pos, float positionInTime ) {
	        	vec3 axis = unpackColor( rotation.x );
	        	float angle = 0.0;

	        	if( rotation.z == 0.0 ) {
		        	angle = mix( 0.0, rotation.y, 1.0 );
		        }
		        else {
		        	angle = mix( 0.0, rotation.y, positionInTime * rotation.z );
		        }

	        	mat4 rotationMatrix = getRotationMatrix( axis, angle );

	        	// vec3 growthStart = vec3( -10.0, -10.0, 0.0 ) * (1.0 - positionInTime);
	        	// vec3 growth = vec3( 10.0, 10.0, 0.0 ) * positionInTime;

	        	// vec3 growth = vec3( 10.0, 10.0, 10.0 ) * positionInTime;

	        	// pos += growthStart;
	        	// pos += growth;

	        	return vec3( rotationMatrix * vec4( pos, 1.0 ) );
	        }

	        void main() {
	        	//
	        	// Setup...
	        	//
	        	float delay = getDelay();
	        	float age = getAge();
	        	float alive = getAlive();
	        	float maxAge = getMaxAge();
	        	float positionInTime = age / maxAge;
	        	float isAlive = when_gt( alive, 0.0 );



	        	// Save the value is isAlive to a varying for
	        	// access in the fragment shader
	        	// vIsAlive = isAlive;



	        	//
	        	// Forces
	        	//

	        	// Get forces & position
	        	float drag = mix(1.0, float(acceleration.w), positionInTime);
	        	// float drag = acceleration.w * positionInTime;
	        	vec3 vel = getVelocity( age );
	        	vec3 accel = getAcceleration( age );
	        	vec3 force = vec3( 0.0 );
	        	vec3 pos = vec3( position );

	        	// vel *= drag;
	        	// vel.y *= drag;

	        	// vec3 drag = vel * positionInTime;
	        	// vel -= drag;

	        	// vel *= acceleration.w * (positionInTime);

	        	// vec3 withVelocity = vec3( force + vel );
	        	// vec3 withAccel = vec3( withVelocity + accel );
	        	// vec3 withDrag = vec3( withAccel );

	        	// Rotate the emitter around it's central point
	        	// pos = getOrbitPosition( pos, positionInTime );

	        	// Integrate forces...
	        	force += vel;
	        	force += accel * age;
	        	// force *= (1.0 - drag) * inversePositionInTime;
	        	// force = getOrbitPosition( force, positionInTime );
	        	pos += force;

	        	// pos.y = 1. - positionInTime;

	        	// pos.y = drag;

	        	// pos.x = positionInTime;
	        	// pos.y = 0.0;
	        	// pos.z = 0.0;

	        	// pos.x += sin( positionInTime * 10.0 );
	        	// pos.y += sin( positionInTime * 10.0 );
	        	// pos.z += cos( positionInTime * 10.0 );


	        	// Rotate the emitter around it's central point
	        	pos = getOrbitPosition( pos, positionInTime );

	        	// pos.x = drag;
	        	// pos.y = drag;
	        	// pos.z = drag;

	        	// Convert pos to a world-space value
	        	vec4 mvPos = modelViewMatrix * vec4( pos, 1.0 );

	        	// Determine point size.
	        	// #ifdef USING_SIZE_OVER_LIFETIME
        			float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;
        		// #else
        			// float pointSize = size.x * isAlive;
        		// #endif

	        	// Determine perspective
	        	// TODO: Accept camera here via `scale` uniform
	        	#ifdef HAS_PERSPECTIVE
	        		float perspective = 300.0 / length( mvPos.xyz );
	        	#else
	        		float perspective = 1.0;
	        	#endif

	        	// Apply perpective to pointSize value
	        	float pointSizePerspective = pointSize * perspective;


	        	//
	        	// Appearance
	        	//

	        	// Determine color and opacity for this particle
	        	// #ifdef USING_COLOR_OVER_LIFETIME
		        	vec3 c = getColorOverLifetime(
		        		positionInTime,
		        		unpackColor( color.x ),
		        		unpackColor( color.y ),
		        		unpackColor( color.z ),
		        		unpackColor( color.w )
		        	) * isAlive;
		        // #else
		        	// vec3 c = unpackColor( color.x ) * isAlive;
	        	// #endif

	        	// #ifdef USING_OPACITY_OVER_LIFETIME
		        	float o = getFloatOverLifetime( positionInTime, opacity ) * isAlive;
		        // #else
		        	// float o = opacity.x * isAlive;
		        // #endif

	        	// Assign color to vColor varying.
	        	vColor = vec4( c, o );

	        	// Determine angle
	        	// vAngle = getFloatOverLifetime( positionInTime, angle ) * isAlive;



	        	//
	        	// Write values
	        	//

	        	// Set PointSize according to size at current point in time.
	        	gl_PointSize = pointSizePerspective;
	        	gl_Position = projectionMatrix * mvPos;
	        }
		</script>

		<script type="text/x-shader" id="fragmentShader">
			varying vec4 vColor;
			// varying float vAngle;
			// varying float vIsAlive;

			void main() {
				// float a = vAngle;
				gl_FragColor = vec4( vColor );
			}
		</script>
	</head>
	<body>
		<script type="text/javascript" src="../../examples/js/THREE-r72.js"></script>
		<script type="text/javascript" src="../../examples/js/Stats.min.js"></script>
		<script type="text/javascript" src="../SPE.js"></script>
		<script type="text/javascript" src="../SPE.TypedArrayHelper.js"></script>
		<script type="text/javascript" src="../SPE.ShaderAttribute.js"></script>
		<script type="text/javascript" src="../SPE.shaders.js"></script>
		<script type="text/javascript" src="../SPE.utils.js"></script>
		<script type="text/javascript" src="../SPE.Group.js"></script>
		<script type="text/javascript" src="../SPE.Emitter.js"></script>

		<script type="text/javascript">
			// Override shaders with ones above.
			SPE.shaders.vertex = document.getElementById( 'vertexShader' ).textContent;
			SPE.shaders.fragment = document.getElementById( 'fragmentShader' ).textContent;


			var scene = new THREE.Scene(),
				camera = new THREE.PerspectiveCamera( 64, window.innerWidth / window.innerHeight, 0.1, 10000 ),
				renderer = new THREE.WebGLRenderer( { antialias: true } ),
				stats = new Stats(),
				clock = new THREE.Clock(),

				group = new SPE.Group(),

				emitter = new SPE.Emitter( {
					particleCount: 5000,

					maxAge: {
						value: 5,
						spread: 5
					},

					// delay: {
					// 	value: 0,
					// 	spread: 0,
					// 	randomize: false
					// },

					rotation: {
						axis: new THREE.Vector3( 0, 1, 0 ),
						angle: Math.PI * 0.5,
						angleSpread: 0,
						speed: 0,
						speedSpread: 0
					},

					// radius: {
					// 	value: 2,
					// 	spread: 0,
					// 	scale: new THREE.Vector3( 1, 1, 1 )
					// },

					position: {
						value: new THREE.Vector3( 0, 0, 0 ),
						spread: new THREE.Vector3( 0, 0, 0 ),
						distribution: SPE.distributions.BOX
					},

					velocity: {
						value: new THREE.Vector3( 0, 6, 0 ),
						spread: new THREE.Vector3( 0, 0, 0 ),
						distribution: SPE.distributions.BOX
					},

					acceleration: {
						value: new THREE.Vector3( 0, 0, 0 ),
						spread: new THREE.Vector3( 0, 0, 2 ),
						distribution: SPE.distributions.BOX
					},

					drag: {
						value: 1,
						spread: 0
					},

					size: {
						value: 1
					},

					color: {
						value: [ new THREE.Color( 0, 1, 0 ), new THREE.Color( 1, 0, 0 ) ]
					},

					opacity: {
						value: [0, 0.5, 1, 0]
					}
				});

			group.addEmitter( emitter );
			scene.add( group.mesh );

			camera.position.z = 50;
			camera.lookAt( scene.position );

			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			document.body.appendChild( stats.domElement );

			function animate() {
				requestAnimationFrame( animate );

				// Simulate low frame-rate
				// setTimeout( animate, 1000 / (Math.random() * 60 | 0) );

				stats.update();
				// camera.position.x = Math.cos( Date.now() * 0.001 ) * 100;
				// camera.position.z = Math.sin( Date.now() * 0.001 ) * 100;
				// camera.lookAt( scene.position );
				render();
			}

			function render() {
				var dt = clock.getDelta();
				group.tick( dt );
				renderer.render( scene, camera );
			}

			console.log( group );
			console.log( emitter );

			animate();

		</script>
	</body>
</html>